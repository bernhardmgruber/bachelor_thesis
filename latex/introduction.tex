\section{Introduction}


\subsection{Motivation}

For a long time the speed of algorithms experienced a constant growth by improved processor hardware. Intel co-founder Gordon E. Moore was one of the first persons to describe this trend in 1965. This description is well known by the name Moore's law which initially stated that the number of transistors on an integrated circuit doubles every year \cite{moore_law}. This trend slowed down and Moore had to change the interval to two years a decade later \cite{moore_law_2003}. The most important consequence however has been realized by one of Moore's co-workers at Intel, David House, who predicted that the performance of processors would double every 18 months \cite{moore_law_2003}. As a result an increase in computing power could be obtained simply by running the same algorithms on newer hardware. As a consequence, hardware dominated the growth of algorithms performance for a long period of time.
\\
Unfortunately, processing hardware technologies hit a limit at the beginning of the third millennium. Physical limits like the size of atoms prevented a further shrink of integrated circuits which would allow an increase in clock speed. As a result, processor vendors started to place multiple CPUs on a single chip. 



\subsection{History of GPGPU Computing}
The development of graphics hardware

shader programming (as first possibility to program for GPUs, focus on graphic calculations, hence the name shader)

Using shaders for GPGPU programming ()

GPGPU Technologies
Cg, CUDA, OpenCL, DirectCompute



\subsection{Goal}
The goal of this thesis is to provide the reader with a state of the art comparison of modern GPU and CPU performance in solving traditional problems such as sorting arrays and multiplying matrices using various algorithms.

why is this goal important?
what could be improved? (how far?)
how could one make use of this? (which companies, domains, areas of application, all?)


what does this document show?
GPGPU acceleration with OpenCL
what is OpenCL? what is GPGPU computing?
example implementations of matrix multiplication, prefix sum and sorting alg.

what is the outcome of my work? (which algorithms profit from GPGPU acc, acceleration vs. invested time)


how do I get to this outcome? (chosen algorithms, used implementations, reference implementations, benchmarks)

\subsection{Chapter overview}


